load sync
load time import time
load os
load string.scanner  # imports str

# FIXME Dao namespaces has to be declared in advance
namespace iar {}

namespace lib {
  DateTimeX, Locale, Kind, Track, Event, Participant,
  events_satisfying, localized_time_format, isrel, mkrel, parse_csv,
  gen_participants
}

interface DateTimeX {
  routine add(invar self: time.DateTime,
    ...: tuple<enum<years, months, days>, int> as vargs) => time.DateTime
}
interface DateTimeX for DateTime {
  routine add(invar self: time.DateTime,
      ...: tuple<enum<years, months, days>, int> as vargs) => time.DateTime {
    self.add(vargs, ...)
    return self
  }
}

#type Locale = enum<cze, eng, slo, ger, fin>
type Locale = enum<cs, en, sk, de, fi>
type Kind = enum<talk, workshop, internal, party>
type Track = enum<tips, world_around, security, challenges, establishment>

type Event = tuple<
  kind: Kind,
  track: Track,
  uri:tuple<
    materials: string,
    video_rec: string,
  >,
  from: time.DateTime,
  to: time.DateTime,
  trans:map<Locale, tuple<
    name: string,
    requirements: string,
    description: string,
    place: string,
  >>,
>

type Participant = tuple<
  # subject name (e.g. 'Name Surname', 'My Cool Company')
  name: string,
  # none ~ person; list<string> ~ references to Participants
  members: none|list<string>,
  photo: string,
  trans: map<Locale, tuple<
    # primary role of this subject (designer(s), analyst(s), manager(s),
    #   programmer, ...)
    role: string,
    note: string,
  >>,
  events: list<Event>,  # events, this person is in charge for
>

routine events_satisfying(
    participants: list<Participant>,
    invar kind: Kind,
    invar track: Track) => list<tuple<name:string, event:Event>> {
  res = (list<tuple<name:string, event:Event>>){}
  participants.iterate { [p]
    p.events.iterate {
      if (X.kind == kind && X.track == track) res.append((p.name, X))
    }
  }
  return res
}

# FIXME this should be achieved using the map capability of the new time module
var mutex_locale = mt.Mutex()
routine localized_time_format(invar locale: string,
    invar t: time.DateTime, invar pattern: string) => string {
  mutex_locale.lock()
  defer { mutex_locale.unlock() }
  old = os.setlocale($time)
  defer { os.setlocale($time, old) }
  os.setlocale($time, locale)
  return t.format(pattern)
}

routine isrel(invar uri: string) {
  #uri[0] != '/'[0] && uri.match('^[^:/]+') == none
  uri[0] != '/'[0] && uri.match('^[a-zA-Z0-9]+:/') == none
}

# FIXME use the os.path module
routine mkrel(from_path: string, invar target_uri: string) => string {
  std.assert(%from_path and %target_uri)
  # FIXME assert that paths are normalized (can't use fs.realpath(), because
  #   it requires file existence)
  if (from_path [0] != '/'[0]) std.error('"from" is not a full path')
  if (from_path[-1] != '/'[0]) from_path += '/'
  if (target_uri[0] != '/'[0]) {
    if (target_uri.match('^[^:/]+') == none)
      std.error('"target" is not a full path nor URI')
    else
      return target_uri
  }

  shared = 1  # /
  while (1) {
    x = target_uri[shared:].fetch('[^/]+')
    y = from_path[shared:].fetch('[^/]+')
    if (%x && x == y)
      shared += %x +1  # +1 for /
    else
      break
  }
  return from_path[shared:].change('[^/]+', '..') + target_uri[shared:]
}

# FIXME read HDD blocks and return only CSV lines in it (if the first
#       CSV line exceeds one block, read following blocks
#       until we have a whole CSV line or reach some huge memory limit)
routine parse_csv(invar path: string) => list<list<string>> {
  f = io.open(path, "r")
  defer { f.close() }

  s = str.Scanner(f.read())
  res = (list<list<string>>){{}}

  while (s.rest) {
    i = 0
    # FIXME \n \t \' can't be matched without enclosing them into []
    # FIXME true;
    for (true; s.scan('[\']'); i += 1) {
      if (s.scan('[^\']+')) {
        if (i)
          res[-1][-1] += '\'' + s.matched()
        else
          res[-1].append(s.matched())
      }
      s.pos += 1  # the closing '
    }

    if (i == 0) {
      if (s.scan('[^\t\n]+')) {
        res[-1].append(s.matched())
        i = 1
      }
    }

    if (s.scan('[\t]')) {
      if (i == 0) res[-1].append('')
    }
    else if (s.scan('[\n]')) {
      res.append({})
    }
    else {
      io.stderr.writeln('ERR Invalid CSV at `' + s.peek(30) + '\'')
    }
  }

  # emptly line before EOF is a useless empty list
  if (! %res[-1]) res.pop()

  return res
}

# FIXME add lunch, dinner, etc.
# FIXME update to the current version of types Event, Participant...
routine gen_participants(invar csv: list<list<string>>) => string {
  res = 'load config import configuration . { conf }
load lib import lib
load time import time
namespace participants_ns { participants }

_participants: list<Participant> = {
'
  csv[1:].iterate { [_line]
    # escape everything for sure
    line = _line.collect { X.replace('\\', '\\\\').replace("'", "\\'") }
    #{
      0  serial number
      1  name + surname
      2  accommodation (patek + sobota)
      3  t-shirt size
      4  preffered day of the talk/workshop
      5  name + surname of personal supporters for the session
      6  accommodation
      7  t-shirt size
      8  type (přednáška|workshop) <unknown>
      9  talk/workshop title
      10 abstract
      11 length of the talk/workshop
      12 name ???
      13 file size
      14 requirements for attendance
      15 note
      16 accepted for voting (usually contains X)
    #}
    if (line[1].convert($lower).match('test') != none)
      io.stderr.writeln('WARN omitting `' + line[1] + "'")
    else
      res +=
"  # personal supporters for the session: " + line[5].replace('\n', '\n#') + "
  ('" + line[1].trim() + "',
  conf.resdir / 'img/participants/" + line[1].trim().convert($lower).change('%s+', '_') + ".png',
  'PERSON/GROUP DESCRIPTION IS MISSING',
  events = {
   # " + line[15].replace('\n', '\n#') + "
   # column12: " + line[12].replace('\n', '\n#') + "
   (" + ( (line[8].trim().match('^workshop$') != none) ? "$workshop" :
    (line[8].trim().match('^přednáška$') != none) ? "$talk" :
    "$unknown" ) + ",
    # " + line[11].replace('\n', '\n#') + "
    time.make(conf.time_to.year, conf.time_to.month, conf.time_to.day" +
      ((line[4].trim().match('^sobota$') != none) ? ' -1' : '') + ", 8, 00),
    time.make(conf.time_to.year, conf.time_to.month, conf.time_to.day" +
      ((line[4].trim().match('^sobota$') != none) ? ' -1' : '') + ", 8, 45),
    trans = {
      $en -> ('" + line[9] + "',
             '" + line[14] + "',
             '" + line[10] + "',
             'UNKNOWN_PLACE',),
      $cs -> ('" + line[9] + "',
             '" + line[14] + "',
             '" + line[10] + "',
             'UNKNOWN_PLACE',),
      $sk -> ('" + line[9] + "',
             '" + line[14] + "',
             '" + line[10] + "',
             'UNKNOWN_PLACE',),
      $de -> ('" + line[9] + "',
             '" + line[14] + "',
             '" + line[10] + "',
             'UNKNOWN_PLACE',),
    }
   )
  }),
"
  }

  return res + '}

var participants: list<Participant> = {}

# remove duplicates
for (_p in _participants) {
  # FIXME (_, p) = ...
  p = participants.find { X.name == _p.name }
  if (p == none)
    participants.append(_p)
  else
    _p.events.iterate { p.value.events.append(X) }
}

# FIXME update according to the current participants.dao
#load web.json
#io.writeln(json.serialize((list<json.Data>)participants))'
}
