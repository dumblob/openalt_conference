#!/usr/bin/env dao

# FIXME check all colors to match the design

load web.html import html
load time as my_time  # conflicting html tag name with module name
load os.fs
load 'config.dao' import configuration
load 'translations.dao' import translation

# /some/full/path/to/file/or/dir/aka/target
# /some/full/path/with/my/current/directory/I/am/in/aka/from/
# ->
# ../../../../../../../../../to/file/or/dir/aka/target
routine mkrel(from: string, invar target: string) => string {
  # FIXME check that paths are normalized (can't use fs.realpath(), because
  #   it requires file existence) and full and not empty
  if (from  [0] != '/'[0]) std.error('"from" is not a full path')
  if (from [-1] != '/'[0]) from += '/'
  if (target[0] != '/'[0]) {
    if (target.match('^[^:/]+') == none)
      std.error('"target" is not a full path nor URI')
    else
      return target
  }

  shared = 1  # /
  while (1) {
    x = target[shared:].fetch('[^/]+')
    y = from[shared:].fetch('[^/]+')
    if (%x && x == y)
      shared += %x +1  # +1 for /
    else
      break
  }
  return from[shared:].change('[^/]+', '..') + target[shared:]
}

routine gen_pages(invar trans: string) {
  # just convenient shortcuts
  invar cu = conf.uri
  invar ci = conf.img
  invar t = translations[trans]

  d = fs.dir(conf.rootdir)
  if (! d.exists(trans)) d.mkdir(trans)
  invar dst = conf.rootdir + '/' + trans

  rel = routine(invar target: string) { return mkrel(dst, target) }

  main_html = 'main.html'
  html5 = io.open(dst + '/' + main_html, 'w')
  defer { html5.close() }

  html5.write(document {
    head {
      title { t['title'] }
      # convenient for relative URLs (see http://www.ietf.org/rfc/rfc1808.txt)
      base(href=conf.base_uri)
      # FIXME why charset must be separately from http_eqiv?
      meta(charset='utf-8')
      meta(http_equiv=$content_type, content='text/html')
      meta(name='viewport', content='width=device-width')
      meta(name='Keywords', content='k1,k2,k3')
      meta(name='Description', content=conf.meta_description)
      link(rel=$icon, _type=conf.favicon.mime, href=rel(conf.favicon.path),
           sizes=conf.favicon.sizes)
      link(rel=$stylesheet, _type='text/css', href=rel(cu.css))
    }
    body {
      # FIXME span input anchor text paragraph strong italic table h1
      #   (style=''
      div(id='top_stripe') {
        div(id='top_stripe_sub00') {
          div(id='top_stripe_nav') {
            anchor(href='#')                                 { t['home'] }
            anchor(href=rel('/page_thanks_'    + conf.lang)) { t['thanks'] }
            anchor(href=rel('/page_gallery_'   + conf.lang)) { t['gallery'] }
            anchor(href=rel('/page_downloads_' + conf.lang)) { t['downloads'] }
            anchor(href=rel('/page_contact_'   + conf.lang)) { t['contact'] }
          }
          div(id='top_stripe_right_part') {
            div(id='top_stripe_links') {
              anchor(href=rel(cu.rss)) {
                img(_class='TopStripeLinks', src=rel(ci.rss),
                    alt=t['rss'])
              }
              anchor(href=rel(cu.twitter)) {
                img(_class='TopStripeLinks', src=rel(ci.twitter),
                    alt=t['twitter'])
              }
              anchor(href=rel(cu.fb)) {
                img(_class='TopStripeLinks', src=rel(ci.fb),
                    alt=t['fb'])
              }
            }
            div(id='top_stripe_lang') {
              paragraph {
                i = 0
                for (invar lang in translations) {
                  if (i)
                    text(' / ')
                  else
                    i += 1
                  if (lang[0] == trans)
                    strong { lang[0] }
                  else
                    anchor(href='../' + lang[0] + '/' + main_html) { lang[0] }
                }
              }
            }
          }
        }
      }
      div(id='header') {
        paragraph {
          img(id='logo_big', src=rel(ci.logo_big), alt=t['logo_big'])
        }
        paragraph { t['motivation'] }
        paragraph {
          strong {
            # FIXME make it LOCALE-aware and then translation tr-aware
            conf.time_from.format('%-d.') + ' - ' +
            conf.time_to.format('%-d. %B %Y')
          }
        }
      }
      div(id='main_buttons') {
        anchor(id='main_button0', href='#talks')     { t['talks'] }
        anchor(id='main_button1', href='#workshops') { t['workshops'] }
        anchor(id='main_button2', href='#schedule')  { t['schedule'] }
      }
      div(id='speakers') {
        paragraph { t['speakers'] }
        paragraph {
          for (pa in participants) {
            if (pa.events.find { X.kind == $internal } == none) {
              img(_class='speaker', src=rel(pa.photo), alt=pa.name)
            }
          }
        }
      }
      div(id='talks') {
        paragraph { t['talks'] }
        paragraph {
          #for (tk in conf.talks) {
          #  img(_class='talk', src=rel(tk[1]), alt=tk[0])
          #}
          'talk00'
        }
      }
      # FIXME the same as talks, but different colors
      div(id='workshops') {
        paragraph { t['workshops'] }
        paragraph {
          #for (sp in conf.workshops) {
          #  paragraph { 'prednaska00' }
          #}
          'workshop00'
        }
      }
      div(id='schedule') {
        paragraph { t['schedule'] }

        events = {}
        participants.iterate { events.append(X.events, ...) }
        events = events.sort { X.from < Y.from }
        last_day = events[0].from - my_time.make(day=1)
        for (e in events) {
          if (e.from.day > last_day.day) {
            last_day = e.from
            paragraph {
              # FIXME make it LOCALE-aware and then translation tr-aware
              last_day.format('%A %-d %-m %Y')
            }
          }
        }
        #for (pa in participants) {
        #  pa.events.sort { X. } .iterate {
        #    tr {
        #      td { X }
        #    }
        #    img(_class='speaker', src=rel(pa.photo), alt=pa.name)
        #  }
        #}

        table {
          tr {
            td { 'abc' }
            td { 'def' }
            td { 'mno' }
            td { 'xyz' }
          }
        }
      }
      div(id='location') {
        paragraph { t['location'] }
        # FIXME dao deadlock or sigsegv
        #img(_class='speaker', src=rel(pa.photo), alt=pa.name)
        #img(src=rel(ci.location), alt=t['location'] + ': ' + conf.coord_gps)
        img(src='../img/map_fit_vutbr.jpg', alt=t['location'] + ': ' + conf.coord_gps)
      }
      div(id='partners') {
        paragraph { t['partners'] }
        paragraph {
          for (invar p in partners) {
            anchor(href=p.uri) {
              img(_class='partner', src=rel(p.img), alt=p.name)
            }
          }
        }
      }
      div(id='footer') {
        paragraph { t['footer'] }
      }
    }
  })
}

# USAGE: generate.dao [<translation>]...
#   if no translations given, generate all
routine main(invar ...: string as args) {
  # FIXME bug?
  #defer (any) { return 0 }

  invar chosen_trs = std.exec {
    if (%args)
      return ((list<string>)args).associate(1) { (X, translations[X]) }
    else
      return translations
  }

  for (invar trans in chosen_trs) {
    fut = gen_pages(trans[0])!!
    defer { fut.value() }
  }

  css = io.open(conf.uri.css, 'w')
  defer { css.close() }

  # FIXME @media only screen and (max-width: 640px) {...}
  css.write(
@[]html {
  background-color: white;
  color: black;
  font: "";
}
body {
  margin: 0;
}
#top_stripe,
#top_stripe a:link,
#top_stripe a:visited,
#top_stripe a:hover,
#top_stripe a:active {
  background-color: black;
  color: white;
  text-decoration: none;
  /*margin: 0 auto 0 auto;*/
  /*width: 700pt;*/
}
#top_stripe_sub00 {
  /*margin: auto 0 auto 100pt;*/
  /*width: 900px;*/
  margin: 0 auto 0 auto;
  position: relative;
}
#top_stripe_nav, #top_stripe_right_part, #top_stripe_links, #top_stripe_lang {
  display: inline-block;
}
#top_stripe_nav {
  width: 75%;
  margin: 0;
}
#top_stripe_right_part {
  width: 25%;
  /*margin: 0 0 0 auto;*/
}
#header {
  margin: 0;
  width: 100%;
  padding: 0 auto 0 auto;
}
#main_buttons {
  width: 50%;
  margin: 0 auto 0 auto;
}
#main_buttons a,
#main_buttons a:link,
#main_buttons a:visited,
#main_buttons a:hover,
#main_buttons a:active {
  /*display: inline;*/
  color: white;
  padding: 20pt 50pt;
  /*height: 135pt;
  width: 65pt;*/
  margin: 0 10pt 0 10pt;
}
#main_button0 {
  background-color: red;
}
#main_button1 {
  background-color: green;
}
#main_button2 {
  background-color: blue;
}
#logo_big {
  /*position: fixed;*/
  /*width: 512px;
  margin: 0 auto 0 auto;*/
}
#speakers, #location {
  background-color: #404040;
  color: white;
}
.speaker {
  height: 150px;
  width: 150px;
  margin: 30px;
  padding: 0;
}
#workshops {
  background-color: #c0c0c0;
}
#schedule {
  background-color: #e03030;
  color: white;
}
#location > p {
  margin 30px auto;
}
#location > img {
  height: 300px;
  width: 100%;
}
#footer * {
  margin: 0;
  background-color: black;
  color: white;
}

@[])
}
