load web.html import html
load time as my_time
load 'config.dao' import configuration
load 'translations.dao' import translation
load 'lib.dao' import lib

#namespace html_page { html_main }
namespace ns_main { html_main }

routine html_main(
    path: string,
    invar trans: string,
    invar dst: string,
    invar pages: map<string, string>) => none {
  html5 = io.open(path, 'w')
  defer { html5.close() }

  # just convenient shortcuts
  invar cu = conf.uri
  invar ci = conf.img
  invar t = translations[trans]

  rel = routine(invar target: string) { return mkrel(dst, target) }

  html5.write(document {
    head {
      title { t['title'] }
      # convenient for relative URLs (see http://www.ietf.org/rfc/rfc1808.txt)
      base(href=conf.base_uri)
      # FIXME why charset must be separately from http_eqiv?
      meta(charset='utf-8')
      meta(http_equiv=$content_type, content='text/html')
      meta(name='viewport', content='width=device-width')
      meta(name='Keywords', content='k1,k2,k3')
      meta(name='Description', content=conf.meta_description)
      link(rel=$icon, _type=conf.favicon.mime, href=rel(conf.favicon.path),
           sizes=conf.favicon.sizes)
      link(rel=$stylesheet, _type='text/css', href=rel(cu.css))
    }
    body {
      div(id='top_stripe') {
        div(id='top_stripe_sub00') {
          div(id='top_stripe_nav') {
            anchor(href='#')                     { t['home'] }
            anchor(href=rel(dst + '/' + pages['about'    ])) { t['about'] }
            anchor(href=rel(dst + '/' + pages['thanks'   ])) { t['thanks'] }
            anchor(href=rel(dst + '/' + pages['gallery'  ])) { t['gallery'] }
            anchor(href=rel(dst + '/' + pages['downloads'])) { t['downloads'] }
            anchor(href=rel(dst + '/' + pages['contact'  ])) { t['contact'] }
          }
          div(id='top_stripe_right_part') {
            div(id='top_stripe_links') {
              anchor(href=rel(cu.rss)) {
                img(_class='TopStripeLinks', src=rel(ci.rss),
                    alt=t['rss'])
              }
              anchor(href=rel(cu.twitter)) {
                img(_class='TopStripeLinks', src=rel(ci.twitter),
                    alt=t['twitter'])
              }
              anchor(href=rel(cu.fb)) {
                img(_class='TopStripeLinks', src=rel(ci.fb),
                    alt=t['fb'])
              }
            }
            div(id='top_stripe_lang') {
              i = 0
              for (invar lang in translations) {
                if (i)
                  text(' / ')
                else
                  i += 1
                if (lang[0] == trans)
                  strong { lang[0] }
                else
                  anchor(href='../' + lang[0] + '/' + pages['main']) { lang[0] }
              }
            }
          }
        }
      }
      div(id='header') {
        paragraph {
          img(id='logo_big', src=rel(ci.logo_big), alt=t['logo_big'])
        }
        paragraph { t['motivation'] }
        paragraph(id='time_range') {
          strong {
            # FIXME make it LOCALE-aware and then translation tr-aware
            conf.time_from.format('%-d.') + '-' +
            conf.time_to.format('%-d. %B %Y')
          }
        }
      }
      div(id='main_buttons') {
        anchor(id='main_button0', href='#talks')     { t['talks'] }
        anchor(id='main_button1', href='#workshops') { t['workshops'] }
        anchor(id='main_button2', href='#schedule')  { t['schedule'] }
      }
      div(id='speakers') {
        h3(_class='section') { t['speakers'] }
        paragraph {
          for (pa in participants) {
            if (pa.events.find { X.kind == $internal } == none) {
              img(_class='speaker', src=rel(pa.photo), alt=pa.name)
            }
          }
        }
      }
      div(id='talks') {
        h3(_class='section') { t['talks'] }
        participants.iterate { [p]
          p.events.iterate { [e]
            #img(_class='talk', src=rel(tk[1]), alt=tk[0])
            if (e.kind == $talk) {
              paragraph(_class='event_title') { e.trans[trans].name }
              paragraph(_class='participant_name') { p.name }
              paragraph(_class='event_desc') { e.trans[trans].description }
            }
          }
        }
      }
      div(id='workshops') {
        h3(_class='section') { t['workshops'] }
        participants.iterate { [p]
          p.events.iterate { [e]
            if (e.kind == $workshop) {
              paragraph(_class='event_title') { e.trans[trans].name }
              paragraph(_class='participant_name') { p.name }
              paragraph(_class='event_desc') { e.trans[trans].description }
              paragraph(_class='participation_reqs') { t['participation_reqs'] }
              paragraph(_class='event_reqs') { e.trans[trans].requirements }
            }
          }
        }
      }
      div(id='schedule') {
        h3(_class='section') { t['schedule'] }

        # FIXME reuse the sorted items (use guard?)
        events = {}
        participants.iterate { [p]
          p.events.iterate { events.append((X, p)) }
        }
        # according to time and place
        events = events.sort {
          # FIXME why need to use value?
          if (X[0].from.value == Y[0].from.value)
            return X[0].trans[trans].place < Y[0].trans[trans].place
          else
            return X[0].from < Y[0].from
        }

        for (i = 0; i < %events;) {
          last_from = events[i][0].from

          paragraph {
            # FIXME make it thread-safe!
            #old = sys.setlocale()
            #defer { sys.setlocale($all, old) }
            #sys.setlocale($time, t['_locale'])
            last_from.format('%A %-d. %-m. %Y')
          }

          table {
            for ((border_top, first_iter) = (true, true);
                 i < %events; i += 1) {
              (e, participant) = events[i]

              if (e.from.year  == last_from.year &&
                  e.from.month == last_from.month &&
                  e.from.day   == last_from.day) {
                # FIXME why need to use value?
                if (e.from.value == last_from.value && ! first_iter)
                  border_top = false
                else
                  border_top = true
              }
              else {
                break
              }

              tr {
                # FIXME class doesn't work - why?
                td(_class=(border_top) ? 'with_border_top' : '') {
                  # FIXME don't mention this image in HTML,
                  #   but use it only in CSS as decoration?
                  img(src=rel(ci.clock))
                  text(e.from.format('%-H:%M'))
                  if (%e.trans[trans].place) {
                    img(src=rel(ci.door))
                    text(e.trans[trans].place)
                  }
                }
                td(_class=(border_top) ? 'with_border_top' : '') {
                  strong { e.trans[trans].name }
                  if (e.kind != $internal) {
                    switch (e.kind) {
                      case $workshop: text(' / ' + t['workshop'])
                      case $talk:     text(' / ' + t['talk'])
                    }
                    text(' / ' + participant.name + ' (' +
                      (string)(my_time.time.diff(e.from, e.to).seconds/60) +
                      ' min)')
                  }
                }
              }

              last_from = e.from
              first_iter = false
            }
          }
        }
      }
      div(id='location') {
        h3(_class='section') { t['location'] }
        img(src=rel(ci.location), alt=t['location'] + ': ' + conf.coord_gps)
      }
      div(id='partners') {
        h3(_class='section') { t['partners'] }
        paragraph {
          for (invar p in partners) {
            anchor(href=p.uri) {
              img(_class='partner', src=rel(p.img), alt=p.name)
            }
          }
        }
      }
      div(id='footer') {
        paragraph { t['footer'] }
      }
    }
  })
}
