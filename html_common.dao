load lib import lib
load web.html import html
load config import configuration
load translations import translation

namespace html_content {
  LocalRefs, html_local_refs,
  html_head, html_top_stripe, html_footer,
}

type LocalRefs = enum<
  home,
  about,
  schedule,
  gallery,
  contact,
  talks,
  workshops,
>

# FIXME $schedule
var html_local_refs: map<LocalRefs, tuple<
    # logical name of the page (real page names are in `pages')
    page:string,
    # real html id attribute
    id:string>> = {
  LocalRefs.home      -> ('home',      ''),
  LocalRefs.about     -> ('about',     ''),
  LocalRefs.schedule  -> ('home',      'schedule'),
  LocalRefs.gallery   -> ('gallery',   ''),
  LocalRefs.contact   -> ('contact',   ''),
  LocalRefs.talks     -> ('talks',     ''),
  LocalRefs.workshops -> ('workshops', ''),
}

routine html_footer(invar trans: Locale) => string {
  # just convenient shortcuts
  invar t = translations[(Locale)trans]

  return fragment {
    div(id='footer') {
      paragraph { t['footer'] }
    }
  }
}

routine html_head(
    invar trans: Locale,
    invar dst: string,
    invar pages: map<string, string>) => string {
  # just convenient shortcuts
  invar cu = conf.uri
  invar t = translations[(Locale)trans]

  rel = routine(invar target: string) { return mkrel(dst, target) }

  return fragment {
    head {
      title { t['title'] }
      # convenient for relative URLs (see http://www.ietf.org/rfc/rfc1808.txt)
      base(href=conf.base_uri)
      # FIXME why charset must be separately from http_eqiv?
      meta(charset='utf-8')
      meta(http_equiv=$content_type, content='text/html')
      meta(name='viewport', content='width=device-width')
      meta(name='Keywords', content='k1,k2,k3')
      meta(name='Description', content=conf.meta_description)
      link(rel=$icon, _type=conf.favicon.mime, href=rel(conf.favicon.path),
           sizes=conf.favicon.sizes)
      link(rel=$stylesheet, _type='text/css', href=rel(cu.css))
      link(rel=$alternate, _type='application/rss+xml',
           href=rel(dst + '/' + pages['feed_rss']))
    }
  }
}

routine html_top_stripe(
    invar page_name: string,
    invar trans: Locale,
    invar dst: string,
    invar pages: map<string, string>) => string {
  # just convenient shortcuts
  invar cu = conf.uri
  invar ci = conf.img
  invar t = translations[(Locale)trans]

  rel = routine(invar target: string) { return mkrel(dst, target) }

  return fragment {
    div(id='top_stripe') {
      nav(_class='segment') {
        for (ref in {
            html_local_refs[LocalRefs.home],
            html_local_refs[LocalRefs.about],
            html_local_refs[LocalRefs.schedule],
            html_local_refs[LocalRefs.gallery],
            html_local_refs[LocalRefs.contact], }) {
          anchor(_class='page_link', href=
                 (ref[0] == page_name) ? '#' + ref[1] :
                 rel(dst + '/' + pages[ref[0]] + '#' + ref[1])) {
            t[(%ref[1]) ? ref[1] : ref[0]]
          }
        }
      }

      div(_class='segment') {
        anchor(_class='ext_link', href=rel(dst + '/' + pages['feed_rss'])) {
          img(src=rel(ci.rss), alt=t['rss'])
        }
        anchor(_class='ext_link', href=rel(cu.twitter)) {
          img(src=rel(ci.twitter), alt=t['twitter'])
        }
        anchor(_class='ext_link', href=rel(cu.gplus)) {
          img(src=rel(ci.gplus), alt=t['gplus'])
        }
        anchor(_class='ext_link', href=rel(cu.fb)) {
          img(src=rel(ci.fb), alt=t['fb'])
        }
      }

      div(_class='segment') {
        i = 0
        for (invar lang in translations) {
          if (i)
            text(' / ')
          else
            i += 1

          lang_str = ((string)lang[0])[1:]
          if ((Locale)lang[0] == (Locale)trans)
            strong(_class='lang_link') { lang_str }
          else
            anchor(_class='lang_link',
                   href='../' + lang_str + '/' + pages[page_name]) {
              lang_str
            }
        }
      }
    }
  }
}
